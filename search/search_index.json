{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Contact Store is a modern API that makes access to contacts on Android devices simple to use.</p> <p>The default way of accessing contacts on Android is based off ContentProviders. Despite powerful, ContentProviders can be error-prone and frustrating to use.</p> <p>Contact Store is a refreshed take on the Contacts API. It provides solutions to contacts' most frequent use cases and uses modern developer practices for an enjoyable developer experience.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install the API using Gradle. In your <code>app/build.gradle</code> include the following dependencies:</p> GroovyKotlin <pre><code>repositories {\n  ...\n  mavenCentral()\n}\n\ndependencies {\n    implementation 'com.alexstyl:contactstore:1.7.0'\n\n    // extension functions for kotlin coroutines\n    implementation 'com.alexstyl:contactstore-coroutines:1.7.0'\n\n    // extension functions for rxJava 3\n    implementation 'com.alexstyl:contactstore-reactive:1.7.0'\n\n    // optional dependency for tests\n    testImplementation 'com.alexstyl:contactstore-test:1.7.0'\n}\n</code></pre> <pre><code>repositories {\n...\nmavenCentral()\n}\n\ndependencies {\nimplementation(\"com.alexstyl:contactstore:1.7.0\")\n\n// extension functions for kotlin coroutines\nimplementation(\"com.alexstyl:contactstore-coroutines:1.7.0\")\n\n// extension functions for rxJava 3\nimplementation(\"com.alexstyl:contactstore-reactive:1.7.0\")\n\n// optional dependency for tests\ntestImplementation(\"com.alexstyl:contactstore-test:1.7.0\")\n}\n</code></pre>"},{"location":"#sample-app","title":"Sample app","text":"<p>Prefer code to documentation? Checkout the sample app</p>"},{"location":"#fetch-all-contacts","title":"Fetch all contacts","text":"<pre><code>val store = ContactStore.newInstance(application)\n\nstore.fetchContacts()\n.collect { contacts -&gt;\nprintln(\"Contacts emitted: $contacts\")\n}\n</code></pre>"},{"location":"#get-details-of-a-specific-contact","title":"Get details of a specific contact","text":"<pre><code>val store = ContactStore.newInstance(application)\n\nstore.fetchContacts(\npredicate = ContactLookup(contactId),\ncolumnsToFetch = allContactColumns()\n)\n.collect { contacts -&gt;\nval contact = contacts.firstOrNull()\nif (contact == null) {\nprintln(\"Contact not found\")\n} else {\nprintln(\"Contact found: $contact\")\n\n// Use contact.phones, contact.mails, contact.customDataItems and\n}\n}\n</code></pre>"},{"location":"#insert-a-new-contact-into-a-gmail-account","title":"Insert a new contact into a Gmail account","text":"<pre><code>val store = ContactStore.newInstance(application)\n\nstore.execute {\ninsert(InternetAcount(\"paolo@gmail.com\", \"gmail.com\")) {\nfirstName = \"Paolo\"\nlastName = \"Melendez\"\nphone(\nvalue = PhoneNumber(\"555\"),\nlabel = Label.PhoneNumberMobile\n)\nmail(\naddress = \"paolo@paolo.com\",\nlabel = Label.LocationWork\n)\nevent(\ndayOfMonth = 23,\nmonth = 11,\nyear = 2021,\nlabel = Label.DateBirthday\n)\npostalAddress(\nstreet = \"85 Somewhere Str\",\nlabel = Label.LocationHome\n)\nwebAddress(\naddress = \"paolo@paolo.com\",\nlabel = Label.LocationWork\n)\ngroupMembership(groupId = 123)\n}\n}\n</code></pre>"},{"location":"#update-an-existing-contact","title":"Update an existing Contact","text":"<pre><code>val foundContacts = store.fetchContacts(\npredicate = ContactLookup(contactId = 5L),\ncolumnsToFetch = listOf(ContactColumn.Note)\n).first()\n\nif (foundContacts.isEmpty()) return // the contact was not found\n\nval contact = foundContacts.first()\n\nstore.execute {\nupdate(contact.mutableCopy {\nnote = Note(\"To infinity and beyond!\")\n})\n}\n</code></pre>"},{"location":"#delete-a-contact","title":"Delete a contact","text":"<pre><code>store.execute {\ndelete(contactId = 5L)\n}\n</code></pre>"},{"location":"#does-contact-store-support-all-features-the-default-contacts-api-does","title":"Does Contact Store support all features the default Contacts API does?","text":"<p>Probably not and this is not the aim of the project. The existing Contacts API has been out there for 10 years or so without much update. It is powerful given that you have access to an SQL-like syntax. I am assuming that a lot of the features it provides were introduced because the platform developers were coding against the ContactProvider interface instead of supporting the features app developers would eventually end up using.</p> <p>Keeping the API lean allows for faster iterations/releases too as there is less things to maintain. I am not saying that eventually all features in the default API are not important or that they will never make it to Contact Store. Instead, I would rather have the features and capabilities of the API to be driven by dev requirements.</p> <p>If you believe you are missing a specific feature, open a new feature request on Github.</p>"},{"location":"#can-i-use-this-api-from-java","title":"Can I use this API from Java?","text":"<p>You should be able to use Contact Store through Java as you can call Kotlin code from Java, but it won't be ideal. Check this Github issue and write your experience.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<p>To report a specific problem or feature request, open a new issue on Github.</p>"},{"location":"#license","title":"License","text":"<p>Apache 2.0. See the LICENSE file for details.</p>"},{"location":"#author","title":"Author","text":"<p>Made by Alex Styl. Follow @alexstyl on Twitter for future updates.</p>"},{"location":"best_practices/","title":"\ud83c\udfce Best practices","text":"<p>This page contains best practices when using the API to ensure the best UX possible.</p>"},{"location":"best_practices/#performance-considerations","title":"Performance considerations","text":""},{"location":"best_practices/#only-request-the-contactcolumns-you-need","title":"Only request the ContactColumns you need","text":"<p>For every ContactColumn requested via the <code>ContactStore#fetchContacts()</code> function, the loading time will increase. This is because Contact Store will perform multiple database queries for every column requested. It is adviced to only request the ContactColumns you need at any given point.</p> <p>Keep in mind that some information about a contact is provided without a need for a <code>ContactColumn</code>.</p> <p>If you are building a list of contacts and you need to display their names, use Contact#displayName instead of requesting for the ContactColumn.Names column. For the same scenario, use the Contact.thumbnailUri instead of querying for the ContactColumn.Image column, if you do no need a high-res version of the contact image.</p>"},{"location":"best_practices/#use-a-predicate-to-quickly-resolve-phone-numbers","title":"Use a Predicate to quickly resolve phone numbers","text":"<p>Instead of fetching all contacts' phone numbers and try to find the contact containing a phone number yourself, use the PhoneLookup predicate.</p> <p>This predicate will try to return the contacts containing the given phone number.</p> <p>Internally, Contact Store utilises a high performant query provided by Android, which makes it ideal for such scenarios.</p>"},{"location":"best_practices/#ux-considerations","title":"UX considerations","text":""},{"location":"best_practices/#use-the-displayname-property-when-showing-the-name-on-the-ui","title":"Use the displayName property when showing the name on the UI","text":"<p>Each contact fetched from the store comes with their <code>displayName</code> property populated. You do not need the <code>Names</code> column to retrieve this information.</p> <p>The <code>displayName</code> might be populated after other properties that are contained in a contact (such as their phone number, if they do not have a name). There is also a high chance that this is the way other apps to represent a contact's name as well.</p>"},{"location":"best_practices/#use-extensions-functions-to-format-phone-numbers-and-postal-addresses","title":"Use extensions functions to format phone numbers and postal addresses","text":"<p>Instead of displaying the raw value of phone numbers and postal address to your UI, prefer using the extension functions found in FormattedStrings.kt. This will convert your properties into formats best suited for UI purposes.</p>"},{"location":"contact_photos/","title":"\ud83d\uddbc Contact photos","text":"<p>Contact Store supports both high resolution images of contacts and thumbnails.</p> <p>High res images can be memory heavy, so it is recommended to use them only when it makes sense to show a good amount of detail in your UI. For the case of rendering a list of contacts, it is advices to use thumbnails instead.</p>"},{"location":"contact_photos/#loading-high-res-images","title":"Loading high res images","text":"<p>In order to get the high resolution image of a contact, you need to fetch the contact using the <code>Image</code> ContactColumn. This will populate the <code>imageData</code> property of the contact. The ImageData object holds a <code>ByteArray</code> of the image. You can provide this array to your image loading library of choice (such as Coil, Glide or Picasso):</p> <pre><code>val store = ContactStore.newInstance(application)\n\ncontactStore.fetchContacts(\npredicate = ContactLookup(listOf(contactId)),\ncolumnsToFetch = listOf(Image)\n).collect {\nval contact = it.firstOrNull()\nif (contact != null) {\nimageView.loadAny(contact.imageData?.raw)\n}\n}\n</code></pre> <p>\u26a0\ufe0f The image loading library you are using might not load images from ByteArrays out of the box. Checkout this issue to learn how to enable such functionality in Coil</p>"},{"location":"contact_photos/#loading-thumbnail-images","title":"Loading thumbnail images","text":"<p>You can get the thumbnail of any contact by using the <code>thumbnailUri</code> extension. As the name suggests, the uri points to the thumbnail image of the contact.</p> <p>You can use the uri with your favorite image loading library to render it on your UI.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>This community seeks the following types of contributions:</p> <ul> <li>Ideas: participate in an issue thread or start your own to have your voice heard.</li> <li>Bug reporting: report any bug you encounter while using the API.</li> <li>Open issues: feel free to work on any Github issue that is not currently assigned to someone else.</li> </ul> <p>Kindly, do not open a PR with work that is not listed as a Github issue or you haven't reached out first.</p>"},{"location":"contributing/#building-the-project","title":"Building the project","text":"<p>After you clone the repository locally, you will notice that the build will fail.</p> <p>This is because one of the scripts used to push a new version to Maven requires some credentials to be present.</p> <p>In order to fix this add the following to your <code>/local.properties</code> file.</p> <pre><code>sonatypeStagingProfileId=\nossrhUsername=\nossrhPassword=\nsigning.keyId=\nsigning.key=\nsigning.password=\n</code></pre> <p>and you are set. You can try running the sample app and everything should work. If not, open a new issue</p>"},{"location":"lookup/","title":"Contact lookup","text":"<p>Contact lookup is a common use case used in apps such as contact search, finding a contact by using a phone number and e-mail suggestion. Contact Store provides ways to quickly look up contacts stored on the device by providing a <code>ContactPredicate</code> when reading contacts</p> <p>The following example uses the <code>ContactIdLookup</code> predicate to retrieve a contact with a given contact id:</p> <pre><code>val store = ContactStore.newInstance(application)\n\nstore.fetchContacts(\npredicate = ContactIdLookup(contactId),\ncolumnsToFetch = allContactColumns()\n)\n.collect { contacts -&gt;\nval contact = contacts.firstOrNull()\nif (contact == null) {\n// Contact not found\n} else {\n// Update your screen using contact\n}\n}\n</code></pre> <p>There are different kind of Predicates you can use:</p>"},{"location":"lookup/#contactidlookup","title":"ContactIdLookup","text":"<p>This predicate will return the contact with the passing contact id.</p>"},{"location":"lookup/#phonelookup","title":"PhoneLookup","text":"<p>This predicate will return any contacts that contain part of the phone number provided.</p>"},{"location":"lookup/#maillookup","title":"MailLookup","text":"<p>This predicate will return any contacts that contain part of the mail address provided.</p>"},{"location":"lookup/#contactlookup","title":"ContactLookup","text":"<p>This predicate will return any contacts that contain the given string to any part of the contact. This is can be used to implement free-text search.</p>"},{"location":"read_contacts/","title":"Reading contacts","text":"<p>Every contact comes with some basic information: the contact ID, the display name and whether they are starred or not.</p> <p>You can request for additional information such as their phone numbers or e-mail addresses by specifying this in your requests.</p> <p>Permission required</p> <p>The examples shown below assume that your app has already been granted the READ_CONTACTS permission. This is not handled by Contact Store.</p> <p>The following snippet returns all contacts present in the device:</p> <pre><code>val store = ContactStore.newInstance(application)\n\nstore.fetchContacts()\n.collect { contacts -&gt;\nprintln(\"All contacts: ${contacts.joinToString(\", \")}\")\n}\n</code></pre>"},{"location":"read_contacts/#columns-to-fetch","title":"Columns to fetch","text":"<p>Depending on your use case, you might need to request additional information about a contact. You can do this by specifying the <code>ContactColumn</code>s that you need. The following example showcase how to get a single contact's <code>PhoneNumber</code>s and names:</p> <pre><code>val store = ContactStore.newInstance(application)\n\nstore.fetchContacts(\npredicate = ContactLookup(contactId),\ncolumnsToFetch = listOf(\nContactColumn.Names,\nContactColumn.Phones\n)\n)\n.collect { contacts -&gt;\nval contact = contacts.firstOrNull()\nif (contact == null) {\nprintln(\"Contact not found\")\n} else {\n// you can now access the contact's phone &amp; names\nval phones = contact.phones\nval contactString = contacts.joinToString(\", \") { contact -&gt;\n\"Names = ${contact.firstName} ${contact.middleName} ${contact.lastName} \" +\n\"phones = ${phones.map { \"${it.value} (${it.label})\" }}\"\n}\nprintln(\"Contacts found: $contactString\")\n}\n}\n</code></pre> <p>Always make sure to query only the <code>ContactColumn</code>s that you need. In the case where a property is accessed which was not queried, an <code>Exception</code> is thrown.</p> <p>If you need to request all available columns, use the <code>allContactColumns()</code> function.</p>"},{"location":"read_contacts/#available-columns","title":"Available columns","text":"<p>The following table shows the mapping between Android's original API and Contact Store's ContactColumn:</p> CommonDataKinds ContactColumn Contact's field(s) populated Phone Phones phones Email Mails mails Event Events events GroupMembership GroupMembership groups Note Note note StructuredPostal PostalAddresses postalAddresses Photo Image imageData StructuredName Names prefix, firstName, middleName, lastName, suffix, phoneticFirstName, phoneticMiddleName, phoneticLastName SipAddresses SipAddresses sipAddresses Relations Relations relations Organization Organization organization, jobTitle Nickname Nickname nickname ImAddresses ImAddresses imAddresses WebAddresses WebAddresses webAddresses Custom data CustomDataItems customDataItems <p>Most properties of the store come as a <code>LabeledValue</code>. Each LabeledValue contains the requested information (such as a phone number) and a user defined <code>Label</code> object (such as 'Mobile', 'Birthday' or custom ones).</p> <p>The labels are used to make it simpler to differentiate similar data items on your apps UI.</p> <p>You can use the <code>Label.getLocalizedString()</code> extension to get a localized version of any label.</p> <p>The <code>LabeledValue</code> class also contains information about which synced account holds the data item. This comes useful when you need to display information from specific account types (say Google).</p>"},{"location":"read_contacts/#custom-data-items","title":"Custom data items","text":"<p>Custom data items include any data items provided by synced accounts that does not fit any other column. It enables custom functionality such as video calling on WhatsApp or messaging via Telegram.</p> <p>Each <code>CustomDataItem</code> contains the mimeType of the item (which represents what the item is, such as a voice call), information for displaying the item on a UI (see summary, detail and icon), and the account that holds the item.</p> <p>You can start an activity using the item like so:</p> <pre><code>val intent = Intent(\nIntent.ACTION_VIEW, ContentUris.withAppendedId(\nContactsContract.Data.CONTENT_URI, customDataItem.id\n)\n)\nstartActivity(intent)\n</code></pre>"},{"location":"read_contacts/#display-name-style","title":"Display Name Style","text":"<p>You can specify the style of the display name you prefer when fetching contacts:</p> <p>The <code>Primary</code> (default) style will return display names in a \"given name first\" fashion for Western names.</p> <p>The <code>Alternative</code> style will return them in a \"family name first\" fashion instead.</p> <p>The returned contacts will be sorted according to the style requested.</p>"},{"location":"testing/","title":"Testing","text":"<p>Contact Store provides an optional <code>com.alexstyl:contactstore-test</code> dependency with testing utilities around contacts.</p>"},{"location":"testing/#contactstore-in-unit-tests","title":"ContactStore in unit tests","text":"<p>As contacts are part of the Android framework, unit testing can be tricky. Developers are either required to depend on frameworks such as Robolectric (which can slow down builds) or implement their own fake abstraction around contacts to hide the dependency to the framework.</p> <p>Contact Store provides a test implementation that is suitable for testing purposes, called <code>TestContactStore</code>.</p> <p>You can initialize the store by providing a list of <code>StoredContact</code>s. This can be used for emulating scenarios where a pre-populated store is needed.</p> <p>\u26a0\ufe0f The implementation of this class tries to match the behavior of AOSP as much as possible.</p> <p>Different OEMs might have altered the behavior of their ContactProvider and as a result different results might be returned. Do not use this class as a source of truth of how a real device will behave.</p> <p>This implementation is meant for unit testing purposes without the need of running the tests on a real Android device or the use of frameworks such as Robolectric.</p>"},{"location":"testing/#example-of-usage","title":"Example of usage","text":"<pre><code>val contactStore = TestContactStore(\ncontactsSnapshot = listOf(\nStoredContact(\ncontactId = 0,\nfirstName = \"Paolo\"\n),\nStoredContact(\ncontactId = 1,\nfirstName = \"Kim\",\nisStarred = true\n)\n)\n)\n</code></pre> <p>You can use this store as if you were running on a real device. You can fetch contacts from it (using <code>fetchContacts()</code>) or update the contacts it holds (using <code>execute()</code>). The internal snapshot will be updated accordingly.</p>"},{"location":"testing/#test-matchers","title":"Test matchers","text":"<p>The <code>samePropertiesAs()</code> matchers return a matcher that matches when the examining object is logically equal to the passing Contact or ContactGroup, minus any ids or lookup keys.</p> <p>This can be useful in testing scenarios where you do not have access to ids, such as Android Tests.</p>"},{"location":"write_contacts/","title":"Writing contacts","text":"<p>Permission required</p> <p>The examples shown below assume that your app has already been granted the WRITE_CONTACTS permission. This is not handled by Contact Store.</p>"},{"location":"write_contacts/#insert-a-new-contact","title":"Insert a new contact","text":"<p>Contact Store provides a flexible way of creating new contacts. The following example shows how to create a new contact:</p> <pre><code>val store = ContactStore.newInstance(application)\n\nstore.execute {\ninsert {\nfirstName = \"Paolo\"\nlastName = \"Melendez\"\nphone(\nvalue = PhoneNumber(\"555\"),\nlabel = Label.PhoneNumberMobile\n)\nmail(\naddress = \"paolo@paolo.com\",\nlabel = Label.LocationWork\n)\n}\n}\n</code></pre> <p>The <code>insert()</code> function takes an optional <code>InternetAccount</code> parameter. The new contact will be stored in the given account if it is editable.</p> <p>Tip</p> <p>You can query all available accounts by using the AccountManager class.</p>"},{"location":"write_contacts/#update-an-existing-contact","title":"Update an existing contact","text":"<p>All contacts emitted by Contact Store are immutable. In order to modify a contact, you first need to get a reference of the contact from the store. The <code>Contact.mutableCopy()</code> function returns a version of the contact that you can modify. Only the values queried can be updated. This is by design, in order to prevent accidental value overrides.</p> <p>Updating the copy's values will not directly update the contacts of the device. When you are happy with your changes and want to commit them, pass the updated contact into <code>update()</code>.</p> <p>The following code modifies a contact's note:</p> <pre><code>val foundContacts = store.fetchContacts(\npredicate = ContactLookup(contactId = 5L),\ncolumnsToFetch = listOf(ContactColumn.Note)\n).first()\nif (foundContacts.isEmpty()) return // the contact was not found\n\nval contact = foundContacts.first()\n\nstore.execute {\nupdate(contact.mutableCopy {\nnote = Note(\"To infinity and beyond!\")\n})\n}\n</code></pre>"},{"location":"write_contacts/#deleting-a-contact","title":"Deleting a contact","text":"<p>The following code shows how to delete a contact by id:</p> <pre><code>store.execute {\ndelete(contactId = 5L)\n}\n</code></pre>"}]}